@page "/BaselineTreeView/{BaselineId:guid}"
@using ItemzApp.WebUI.Client.Services.BaselineHierarchy
@using ItemzApp.WebUI.Client.Services.Baselines
@using ItemzApp.WebUI.Client.SharedModels
@using Microsoft.AspNetCore.Components.Forms
@using System.Collections.ObjectModel
@inject NavigationManager NavManager
@inject IDialogService DialogService

<MudGrid Spacing="6" Justify="Justify.FlexStart">
    <MudItem xs="6">
        <MudPaper Width="500px" Elevation="0">
            @if (showLoadingMessage)
            {
                @* <MudText Typo="Typo.button" Color="Color.Secondary" HtmlTag="h3" Align="Align.Center"> Loading in Background ... </MudText> *@
                <MudText Typo="Typo.button" Color="Color.Secondary" HtmlTag="h3" Align="Align.Center"> Loading in Background ... </MudText>
                <MudProgressLinear Color="Color.Secondary" Indeterminate="true" Class="my-7" />
            }
            else
            {
                <MudButton OnClick="@(()=>baselineMudTreeView.ExpandAllAsync())" Variant="Variant.Filled">Expand All</MudButton>
            }
            <MudTreeView @ref="baselineMudTreeView" Items="@InitialTreeItems"
                         Color="Color.Secondary"
                         Hover="true"
                         ExpandOnDoubleClick="true"
                         Width=" 100%">
                <ItemTemplate>
                    @{
                        // Casting context from TreeItemData<string> to our own derived class TreeItemPresenter
                        // for convenient usage in the template
                        var presenter = context as TreeItemPresenter;
                    }
                    <MudTreeViewItem Value="@context.Value"
                                     Text="@context.Text"
                                     Icon="@context.Icon"
                                     Expandable="@( @context.Children.Count()>0 ? true : false )" 
                                     LoadingIconColor="Color.Info"
                                     Items="@context.Children"
                                     EndText="@( 
                                        (@presenter.Children.Count() > 0 ? ("[C" + @presenter.Children.Count().ToString() + "]") : "") + 
                                        (@presenter.Level > 0 ? ("[L" + @presenter.Level.ToString() + "]") : "")
                                        )" 
                    />
                                     @* CanExpand="@( @context.Children.Count()>0 ? true : false )" 
                                     EndText="@presenter?.childNumber" /> *@
                </ItemTemplate>
            </MudTreeView>
        </MudPaper>
    </MudItem>
</MudGrid>


@code {

    [Parameter]
    public Guid BaselineId { get; set; }

    [Inject]
    public IBaselinesService BaselinesService { get; set; }

    [Inject]
    public IBaselineHierarchyService BaselineHierarchyService { get; set; }

    public MudTreeView<Guid> baselineMudTreeView;

    private bool showLoadingMessage = true;

    private List<TreeItemData<Guid>> InitialTreeItems { get; set; } = new();


    public BaselineHierarchyIdRecordDetailsDTO singleBaseline { get; set; } = new();
    private List<BaselineHierarchyIdRecordDetailsDTO> AllItemzTypesForBaseline { get; set; } = new List<BaselineHierarchyIdRecordDetailsDTO>();
    public bool initializingPage { get; set; } = false;


    public class TreeItemPresenter : MudBlazor.TreeItemData<Guid>
    {
        public string RecordType { get; set; }
        public int? Level { get; set; }
        public bool IsIncluded { get; set; }

        public TreeItemPresenter(Guid value, string text, string icon
            , string recordType, int? level, bool expandable, bool isIncluded ) : base(value)
        {
            Value = value;
            Text = text;
            Icon = icon;
            RecordType = recordType;
            Level = level ?? 0 ;
            Expandable = expandable;
            IsIncluded = isIncluded;
            Children = new List<TreeItemData<Guid>>();
        }
    }

    public void AddChildrens(TreeItemData<Guid> parentTempTreeViewNode, List<NestedBaselineHierarchyIdRecordDetailsDTO> Children )
    {
        foreach (var child in Children)
        {

            var childTempTreeViewNode = new TreeItemPresenter
                (
                    value: child.RecordId
                    , text: child.Name
                    , icon: (child.RecordType.ToLower() == "baselineitemztype" ? @Icons.Material.Filled.Pix :
                                                   child.RecordType!.ToLower() == "baselineitemz" ? @Icons.Material.Filled.Stream : @Icons.Material.Filled.Cancel)
                    , recordType: child.RecordType
                    , level: child.Level
                    , expandable: (child.Children.Count() > 0 ? true : false)
                    , isIncluded: child.isIncluded
                );

            if (child.Children.Count() > 0)
            {
                AddChildrens(childTempTreeViewNode, child.Children);
            }

            parentTempTreeViewNode.Children.Add(childTempTreeViewNode);
        }
    }

    private async Task<List<TreeItemData<Guid>>> LoadInitialData(Guid BaselineId)
    {
        // Load initial set of tree nodes

        singleBaseline = await BaselineHierarchyService.__Get_BaselineHierarchy_Record_Details_By_GUID__Async(BaselineId);

        if (singleBaseline == null)
        {
            throw new ApplicationException($"No Baseline record found for GUID {BaselineId}");
        }

        var tempTreeView = new TreeItemPresenter
             (
                 value: singleBaseline.RecordId
                 , text: singleBaseline.Name
                 , icon: @Icons.Material.Filled.ContentCopy // TODO :: ICON CAN BE ELEGENTLY HANDLED BASED ON RECORD TYPE
                 , recordType: singleBaseline.RecordType
                 , level: singleBaseline.Level
                 , expandable: true
                 , isIncluded: singleBaseline.IsIncluded
             );

        List<TreeItemData<Guid>> _children = new();

        var returnedBaselineItemzTypeList = await BaselineHierarchyService.__Get_Immediate_Children_Baseline_Hierarchy_By_GUID__Async(BaselineId);

        if (returnedBaselineItemzTypeList!.Count() > 0)
        {
            foreach (var _baselineItemzType in returnedBaselineItemzTypeList!)
            {
                _children.Add(new TreeItemPresenter
                                (
                value: _baselineItemzType.RecordId
                , text: _baselineItemzType.Name
                , icon: _baselineItemzType.RecordType!.ToLower() == "baseline" ? @Icons.Material.Filled.ContentCopy :
                                                     _baselineItemzType.RecordType!.ToLower() == "baselineitemztype" ? @Icons.Material.Filled.Pix :
                                                             _baselineItemzType.RecordType!.ToLower() == "baselineitemz" ? @Icons.Material.Filled.Stream : @Icons.Material.Filled.Cancel
                , recordType: _baselineItemzType.RecordType
                , level: _baselineItemzType.Level
                , expandable: true
                , isIncluded: _baselineItemzType.IsIncluded
                ));

            }

            // Update the tree items with additional data
            foreach (var node in _children)
            {
                tempTreeView.Children.Add(node);
            }
        }

        List<TreeItemData<Guid>> tempList = new();

        tempList.Add(tempTreeView);

        return tempList;
    }

    private async Task<List<TreeItemData<Guid>>> LoadAllBaselineHierarchyData(Guid BaselineId)
    {
        List<TreeItemData<Guid>> _baselineHierarchyTreeNodes = new();


        // Load initial set of tree nodes

        singleBaseline = await BaselineHierarchyService.__Get_BaselineHierarchy_Record_Details_By_GUID__Async(BaselineId);

        if (singleBaseline == null)
        {
            throw new ApplicationException($"No baseline record found for GUID {BaselineId}");
        }

        var _tempTreeViewBaselineNode = new TreeItemPresenter
            (
                value: singleBaseline.RecordId
                , text: singleBaseline.Name
                , icon: @Icons.Material.Filled.ContentCopy
                , recordType: singleBaseline.RecordType
                , level: singleBaseline.Level
                , expandable: true
                , isIncluded: singleBaseline.IsIncluded
            );

        _baselineHierarchyTreeNodes.Add(_tempTreeViewBaselineNode);

        var allHierarchyDataFromAPI = await BaselineHierarchyService.__Get_All_Children_Baseline_Hierarchy_By_GUID__Async(BaselineId);

        if (allHierarchyDataFromAPI != null)
        {

            foreach (var singleHierarchyDataFromAPI in allHierarchyDataFromAPI)
            {
                TreeItemData<Guid> childTempTreeViewNode = new TreeItemPresenter
                    (
                        value: singleHierarchyDataFromAPI.RecordId
                        , text: singleHierarchyDataFromAPI.Name
                        , icon: (singleHierarchyDataFromAPI.RecordType.ToLower() == "baselineitemztype" ? @Icons.Material.Filled.Pix :
                                            singleHierarchyDataFromAPI.RecordType!.ToLower() == "baselineitemz" ? @Icons.Material.Filled.Stream : @Icons.Material.Filled.Cancel)
                        , recordType: singleHierarchyDataFromAPI.RecordType
                        , level: singleHierarchyDataFromAPI.Level
                        , expandable: (singleHierarchyDataFromAPI.Children.Count() > 0 ? true : false)
                        , isIncluded: singleHierarchyDataFromAPI.isIncluded
                    );

                if (singleHierarchyDataFromAPI.Children.Count() > 0)
                {
                    AddChildrens(childTempTreeViewNode, singleHierarchyDataFromAPI.Children);
                }

                _baselineHierarchyTreeNodes.FirstOrDefault()!.Children!.Add(childTempTreeViewNode);

            }

        }
        return _baselineHierarchyTreeNodes;
    }
    // protected async override void OnInitialized()
    // {
    //     // Load initial data
    //     InitialTreeItems = await LoadInitialData(BaselineId);
    //     StateHasChanged();

    // }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {

            // Load initial data
            InitialTreeItems = await LoadInitialData(BaselineId);
            StateHasChanged();

            Thread.Sleep(900);
            // Load Entire Baseline Hierarchy data
            InitialTreeItems = await LoadAllBaselineHierarchyData(BaselineId);

            showLoadingMessage = false; 
            StateHasChanged();
        }
    }

 }